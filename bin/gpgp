#!/usr/bin/env bash
#
# gpg Plus
#
# by @alexebird
#

set -euo pipefail
. "${DAVINCI_CLONE}/sh/01-colors.sh"

[ -n "${GPGP_VERBOSE:-}" ] && set -x

GPG='gpg'

_join() {
  local joint="${1:-}"
  shift
  local i=0
  for e in "$@"; do
    echo -n "${e}"
    ((i++))
    if [[ "${i}" != "$#" ]]; then
      echo -n "${joint}"
    else
      echo
    fi
  done
}

gpgp::role_path() {
  echo "${DAVINCI_GPGP_PATH}/gpgp/roles/${1:-}"
}

gpgp::pub_key_path() {
  echo "${DAVINCI_GPGP_PATH}/gpgp/public/${1:-}"
}

gpgp::secrets_path() {
  echo "${DAVINCI_GPGP_SECRETS_PATH}/${1:-}"
}

gpgp::ls_roles() {
  find "$(gpgp::role_path)" -type f -printf '%f\n' | sort
}

gpgp::ls_pub_keys() {
  find "$(gpgp::pub_key_path)" -type f -printf '%f\n' | sort
}

gpgp::is_role() {
  gpgp::ls_roles | grep -qP "^${1}$"
}

gpgp::is_pub_key_auto_role() {
  gpgp::ls_pub_keys | grep -qP "^${1}@.+\.pub$"
}

gpgp::is_pub_key() {
  local thing="${1}"
  gpgp::ls_pub_keys | grep -q "${thing}"
}

gpgp::is_comment() {
  local thing="${1}"
  [[ "${thing}" == '#'* ]]
}

gpgp::get_id_from_key_fname() {
  local fname="$1"
  echo "${fname}" | sed -n -e's/.*id:\([0-9A-Z]\+\).*/\1/p'
}

gpgp::get_id_from_auto_role() {
  local auto_role="$1"
  local fname="$(gpgp::ls_pub_keys | grep -P "^${auto_role}@.+\.pub$")"
  gpgp::get_id_from_key_fname "${fname}"
}

gpgp::ls_auto_roles() {
  gpgp::ls_pub_keys | grep -oP "^.+(?=@)"
}


#
# Recursively flatten roles into a list of the public key files.
#
gpgp::flatten_role() (set -euo pipefail
  local role="${1:?must pass role}" ; shift
  local output_indent_level="${1:?must pass output_indent_level}" ; shift
  local verbose="${1:-false}" ; shift

  local padding=""
  local one_padding="  "

  for (( i=0; i<output_indent_level; i++ )); do
    padding+="${one_padding}"
  done

  if gpgp::is_pub_key_auto_role "${role}"; then
    local key_id="$(gpgp::get_id_from_auto_role "${role}")"

    if [[ "${verbose}" == "true" ]]; then
      echo "${padding}${role} (${key_id})"
    else
      echo "${key_id}"
    fi

    return 0
  fi

  if ! gpgp::is_role "${role}"; then
    echo "couldn't find role: ${role}"
    return 2
  fi

  if [[ "${verbose}" == "true" ]]; then
    echo "${padding}role: ${role} ($(gpgp::role_path "${role}"))"
  fi

  local role_path="$(gpgp::role_path "${role}")"
  local role_contents="$(cat "${role_path}")"

  for e in ${role_contents}; do
    if gpgp::is_comment "${e}"; then
      continue
    fi

    if gpgp::is_role "${e}" || gpgp::is_pub_key_auto_role "${e}"; then
      gpgp::flatten_role "${e}" "$((output_indent_level + 1))" "${verbose}"
    else
      echo "${e} is not a role"
      return 2
    fi
  done

  if [[ "${verbose}" == "true" ]] && [[ "${output_indent_level}" == "0" ]]; then
    echo
  fi
)

gpgp::recipients_list_from_roles() {
  local roles="$@"
  local key_ids="$(gpgp::cmd_ls false ${roles} | sort | uniq)"

  if [[ -n "${key_ids}" ]]; then
    echo "-r $(_join ' -r ' ${key_ids})"
  else
    echo "error: did you want some roles?"
    exit 1
  fi
}

gpgp::cmd_recips() {
  local roles="$@"
  local recips="$(gpgp::recipients_list_from_roles ${roles})"

  if [[ "$?" != "0" ]]; then
    return 1
  else
    echo "${recips}"
  fi
}

gpgp::cmd_ls() {
  local verbose="$1" ; shift
  local roles="$@"

  for role in "$@"; do
    gpgp::flatten_role "${role}" 0 "${verbose}"
  done
}

gpgp::cmd_import() {
  local dry_run='false'

  while getopts "hn" opt; do
    case "${opt}" in
      n)
        dry_run='true'
        echo "dry run!"
        echo
        ;;
      h)
        cat <<HERE
  -n    dry run
  -h    show this help text
HERE
          exit
        ;;
      \?)
        echo "invalid option: -${OPTARG}" >&2
        exit 1
        ;;
      :)
        echo "option -${OPTARG} requires an argument." >&2
        exit 1
        ;;
    esac
  done

  # these are the key ids we want to end up having imported at the end of the process.
  local desired_keys="$(gpgp::cmd_ls false $(gpgp::ls_roles) | sort | uniq)"
  echo "$(gpgp::cmd_ls false $(gpgp::ls_roles) | sort | uniq)"

  # get currently imported public keys for the owner's domains
  local current_keys=$(
    "${GPG}" --list-keys \
      | grep -B1 -P "${DAVINCI_GPGP_EMAIL_DOMAINS}" \
      | grep -vP "${DAVINCI_GPGP_PUB_KEY_ID_BLACKLIST}" \
      | grep pub \
      | sed -n -e's;^pub.\+\/\(.\+\) .\+$;\1;p' \
      | sort \
      | uniq
  )

  # we will import everything in desired_keys.
  # we will --delete-key on everything that is in only current_keys.

  # take the set difference to get the keys only in current_keys.
  local delete_keys=$(
    comm -1 -3 \
      <(echo -e "${desired_keys}" | sed -e's/ /\n/g' | sort) \
      <(echo -e "${current_keys}" | sed -e's/ /\n/g' | sort)
  )

  echo desired: ${desired_keys}
  echo current: ${current_keys}
  echo delete:\ \ ${delete_keys}
  echo

  local desired_regex="$(_join '|' ${desired_keys})"
  local cmd

  if [[ -n "${desired_regex}" ]]; then
    for f in $(find "$(gpgp::pub_key_path)" -type f -name '*.pub' | grep -P "${desired_regex}") ; do
      cmd="${GPG} --import ${f}"
      echo "${cmd}"
      if [[ "${dry_run}" != "true" ]]; then
        ${cmd}
      fi
      echo
    done
  fi

  if [[ -s "${DAVINCI_GPGP_PATH}/gpg/ownertrust.txt" ]]; then
    "${GPG}" --import-ownertrust "${DAVINCI_GPGP_PATH}/gpg/ownertrust.txt"
  fi

  for f in ${delete_keys} ; do
    cmd=""${GPG}" --batch --yes --delete-key ${f}"
    echo "${cmd}"
    if [[ "${dry_run}" != "true" ]]; then
      ${cmd}
    fi
    echo
  done
}

gpgp::cmd_encrypt() {
  local gpg_opts=''
  local rm_orig='false'

  while getopts "ho:r" opt; do
    case "${opt}" in
      r)
        rm_orig="true"
        ;;
      o)
        gpg_opts="${OPTARG}"
        ;;
      h)
        cat <<HERE
gpgp encrypt [OPTIONS] ROLE [ROLE...] [FILE | -]

If FILE is equal to '-', then gpgp expects some data to piped in via stdin, and
writes the encrypted output in ascii-armor to stdout.

  -o    More options to be passed directly to gpg (wrap in quotes).
  -r    Remove the original unencrypted file.
  -h    Show this help text.
HERE
          exit
        ;;
      \?)
        echo "invalid option: -${OPTARG}" >&2
        exit 1
        ;;
      :)
        echo "option -${OPTARG} requires an argument." >&2
        exit 1
        ;;
    esac
  done

  shift $(($OPTIND - 1))

  # convert roles to an array
  local roles=( "$@" )

  # convention: the last arg is the file to encrypt
  local file="${roles[${#roles[@]}-1]}"

  if [[ -n "${gpg_opts}" ]]; then
    gpg_opts="${gpg_opts} "
  fi

  # if no existing file is passed as the last arg, read from stdin, ascii armor, write to stdout.
  #if [[ -t 1 ]] || [[ "${file}" == '-' ]]; then
  if [[ "${file}" == '-' ]]; then
    # read from stdin, write to stdout
    gpgp::validate_roles ${roles}
    cat - | "${GPG}" ${gpg_opts}-a -e $(gpgp::cmd_recips ${roles}) -o-

  # if a file is passed as the last arg, encrypt it.
  elif [[ -f "${file}" ]]; then
    # remove the file from the list of args so we are only left with a list of roles
    unset 'roles[${#roles[@]}-1]'
    outf=''
    gpgp::validate_roles ${roles[@]}
    "${GPG}" ${gpg_opts}-e $(gpgp::cmd_recips ${roles[@]}) "${file}"

    if [[ "${rm_orig}" == "true" ]]; then
      echo "encrypted '${file}' -> '${file}.gpg'"
      rm -v "${file}"
    fi
  else
    echo "gpgp: error: file doesnt exist: ${file}"
    exit 1
  fi
}

gpgp::secrets_find_role_file() {
  local dir="${1:?must pass dir}" ; shift
  local orig_dir="${dir}"
  local role_file

  while true; do
    role_file="$(find "${dir}" -maxdepth 1 -type f -name 'gpgp-role:*' | grep --color=never -P '(:.+)')"

    if [[ -f "${role_file}" ]]; then
      echo "${role_file}"
      return 0

    # if we can't move upwards anymore
    elif [[ "${DAVINCI_GPGP_SECRETS_PATH%/}" == "${dir%/}" ]]; then
      echo ""
      return 1

    else
      # move upwards in the directory tree
      dir="$(dirname "${dir}")"
    fi
  done
}

# The assumption is that the secrets dir is versioned, so this can do potentially
# destructive actions. We should guard against unencrypted secrets being added
# to version control, which we do.
gpgp::secrets_reencrypt_dir() {
  local dir="${1:?must pass dir}" ; shift
  local dry_run="${1:-false}" ; shift

  local role_file="$(gpgp::secrets_find_role_file "${dir}")"
  # if there's no role file, check if `dir` has only other directories in it, meaning
  # there are no secrets in `dir` to protect from not being encrypted, and thus it's okay
  # if `dir` contains no role file. return 0 in that case, because there are no secrets
  # to reencrypt in `dir`.
  if [[ -z "${role_file}" ]]; then
    # how many regular files in are in dir?
    if [[ "$(find "${dir}" -maxdepth 1 -name '.git' -prune -o -type f -print | wc -l)" == "0" ]]; then
      # if there are none, don't bother to do anything else because the dir has no secrets to encrypt.
      return 0
    else
      >&2 echo "role file not found for directory ${dir} or in any parent dir."
      return 1
    fi
  fi

  local role="$(echo "${role_file}" | grep --color=never -oP '(?<=:).*')"
  local roles="${role} admin"

  gpgp::validate_roles ${roles}

  # if it ends with gpg, re-encrypt.
  for secret in $(find "${dir}" -maxdepth 1 -type f -name '*.gpg') ; do
    echo -e "${COLOR_YELLOW}+/- reencrypting${COLOR_RESET} ${secret}"

    if [[ "${dry_run}" == "false" ]]; then
      local tmp_secret="${secret/%gpg/__new.gpg}"
      rm -f "${tmp_secret}"
      # dont ever write the unencrypted secret to disk when reencrypting.
      cat "${secret}" \
        | "${GPG}" -d -o- \
        | "${GPG}" -e $(gpgp::cmd_recips ${roles}) -o"${tmp_secret}"
      mv "${tmp_secret}" "${secret}"
    fi
  done

  # if it doesn't end with gpg, just encrypt and delete original.
  # if the file ends with '.cleartext', dont worry about encrypting it.
  for secret in $(find "${dir}" -maxdepth 1 -name '.git' -prune -o \( -type f -a -not -name '*.gpg' -a -not -name 'gpgp-role:*' \) -print) ; do
    echo -e "${COLOR_GREEN}+ encrypting${COLOR_RESET} ${secret} -> ${secret}.gpg"

    if [[ "${dry_run}" == "true" ]]; then
      continue
    fi

    if [[ "${secret}" != *.cleartext ]]; then
      gpgp::cmd_encrypt -o '--batch --yes' ${roles} "${secret}"
      rm -v "${secret}"
    fi
  done

  {
    echo -e "\ndir:  ${dir}\n"
    gpgp::cmd_ls true ${roles}
  } | sed -e's/^/    /'
}

gpgp::cmd_add-key() {
  local dry_run='false'

  while getopts "hn" opt; do
    case "${opt}" in
      n)
        dry_run='true'
        echo "dry run!"
        echo
        ;;
      h)
        cat <<HERE
gpgp add-key [OPTIONS]

Reads a public gpg key from stdin and stores it by the correct conventions.

  -n    dry run
  -h    show this help text
HERE
          exit
        ;;
      \?)
        echo "invalid option: -${OPTARG}" >&2
        exit 1
        ;;
      :)
        echo "option -${OPTARG} requires an argument." >&2
        exit 1
        ;;
    esac
  done

  shift $(($OPTIND - 1))

  local new_tmp="$(gpgp::pub_key_path '_tmp-new.pub')"
  cat - > "${new_tmp}"

  if ! grep -q 'BEGIN PGP PUBLIC KEY BLOCK' "${new_tmp}"; then
    echo "gpgp add-key: input doesnt seem to be a public key"
    return 1
  fi

  local key_fingerprint="$(gpg --with-fingerprint "${new_tmp}" 2>&1)"

  local key_id_short="$(echo "${key_fingerprint}" | ruby -ne '$_ =~ /^pub.+\/([0-9A-Z]+)/ && puts($1)')"
  local role_name="$(echo "${key_fingerprint}" | ruby -ne '$_ =~ /\<(.+)@/ && puts($1)')"
  local key_size="$(echo "${key_fingerprint}" | ruby -ne '$_ =~ /^pub\s+([0-9A-Z]+)\// && puts($1)')"
  local email="$(echo "${key_fingerprint}" | ruby -ne '$_ =~ /\<(.+)\>/ && puts($1)')"
  local key_id_long="$(echo "${key_fingerprint}" | ruby -ne '$_ =~ /Key fingerprint = ([0-9A-Z ]+)$/ && puts($1.gsub(/\s+/, ""))')"

  local key_fname="${email}-${key_size}-id:${key_id_short}.pub"

  if [[ "${dry_run}" == 'true' ]]; then
    rm -f "${new_tmp}"
    echo "key fname: ${key_fname}"
    echo "role name: ${role_name}"
  else
    mv -f "${new_tmp}" "$(gpgp::pub_key_path "${key_fname}")"
    echo "${key_fname}" > "$(gpgp::role_path "${role_name}")"
    if ! grep -q "${key_id_long}" "${DAVINCI_GPGP_PATH}/gpg/ownertrust.txt"; then
      echo "${key_id_long}:6:" >> "${DAVINCI_GPGP_PATH}/gpg/ownertrust.txt"
    fi
  fi
}

gpgp::cmd_reencrypt() {
  local dry_run='false'
  local secrets_path

  while getopts "hn" opt; do
    case "${opt}" in
      n)
        dry_run='true'
        echo "dry run!"
        echo
        ;;
      h)
        cat <<HERE
gpgp reencrypt [OPTIONS] [SECRETS_PATH]

SECRETS_PATH defaults to DAVINCI_GPGP_SECRETS_PATH, otherwise
must be inside DAVINCI_GPGP_SECRETS_PATH.

  -n    dry run
  -h    show this help text
HERE
          exit
        ;;
      \?)
        echo "invalid option: -${OPTARG}" >&2
        exit 1
        ;;
      :)
        echo "option -${OPTARG} requires an argument." >&2
        exit 1
        ;;
    esac
  done

  shift $(($OPTIND - 1))

  secrets_path="${1:-}"

  if [[ -z "${secrets_path}" ]]; then
    secrets_path="${DAVINCI_GPGP_SECRETS_PATH}"
  elif [[ "${secrets_path}" == *..* ]]; then
    echo "no '..' allowed in SECRETS_PATH"
    exit 1
  else
    secrets_path="${DAVINCI_GPGP_SECRETS_PATH}/${secrets_path}"
  fi

  # try to do a dry run first
  echo "checking for roles"
  echo "=================="
  echo
  if gpgp::cmd_reencrypt_dirs 'true' "${secrets_path}"; then
    echo "check passed. ready to encrypt."
    echo

    if [[ "${dry_run}" == 'false' ]]; then
      echo "re-encrypting secrets"
      echo "====================="
      echo
      gpgp::cmd_reencrypt_dirs 'false' "${secrets_path}"
    fi
  else
    echo "check failed. no encryption was done."
  fi
}

gpgp::cmd_find-secrets() {
  local search_terms="$@"
  local grep_pattern=''

  for t in ${search_terms}; do
    grep_pattern=" -e ${t}"
  done

  if [[ -n "${grep_pattern}" ]]; then
    grep_pattern=" | grep --color=always -iP ${grep_pattern}"
  fi

  eval find "${DAVINCI_GPGP_SECRETS_PATH}" -type f -name '*.gpg' ${grep_pattern}
}

gpgp::cmd_reencrypt_dirs() {
  local dry_run="$1" ; shift
  local secrets_path="$1" ; shift
  # reverse sort here so that lower-depth dirs are encrypted first, so that their roles will be
  # applied correctly.
  for dir in $(find "${secrets_path}" -name '.git' -prune -o -type d -print | sort -r) ; do
    gpgp::secrets_reencrypt_dir "${dir}" "${dry_run}" || return 1
    echo
  done
}

#gpgp::roles_completer() {
  #gpgp::ls_roles
  #echo
#}

#complete -F _gpgp_roles_completer _gpgp_recipients_list

gpgp::validate_roles() {
  local roles="$@"
  for role in "$@"; do
    if ! gpgp::is_role "${role}" && ! gpgp::is_pub_key_auto_role "${role}" ; then
      >&2 echo "couldn't find role: ${role}"
      exit 1
    fi
  done
}

gpgp::usage() {
  cat <<HERE
usage: gpgp SUBCMD [OPTIONS] ...

SUBCMD defaults to encrypt.

Subcommands:

(run each subcommand with -h for more info)

encrypt     Ecrypt a file with one or more roles.
recips      Prints a \`-r FOOBAR -r BAR...\` string for use with gpg.
ls          Prints the role heirarchy for all roles.
ls ROLE...  Prints the role heirarchy for the specified roles.
import      Imports the public keys at DAVINCI_GPGP_PATH, and the ownertrust.txt file.
add-key     Read a public gpg key from stdin, store it by the correct conventions, add it to ownertrust.txt.
reencrypt   Reencrypts the secrets at DAVINCI_GPGP_SECRETS_PATH.
HERE
}

gpgp::assert_gpgp_config() {
  if [[ -z "${DAVINCI_GPGP_EMAIL_DOMAINS:-}" ]]; then
    echo "gpgp cannot be used when DAVINCI_GPGP_EMAIL_DOMAINS is not set."
    return 1
  fi
  return 0
}

# TODO always reencrypt with admins
# TODO dont allow for circular deps in role hierarchy
gpgp::assert_roles_valid() {
  local roles="$(gpgp::ls_roles)"

  # check to make sure no roles exist which collide with auto-roles.
  for r in $(gpgp::ls_roles); do
    if echo "${r}" | grep -P "$(_join '|' $(gpgp::ls_auto_roles))" ; then
      echo "error: the role '${r}' has the same name as the public key '$(gpgp::ls_pub_keys | grep "${r}")'"
      return 1
    fi
  done


  # check to make sure that all roles mentioned in other roles are, in fact, roles.
  local output
  local rv='0'

  for role in ${roles}; do
    output="$(
      gpgp::flatten_role "${role}" 0 true
    )" || { rv=$? ; }

    if [[ "${rv}" -ne 0 ]]; then
      echo "${output}"
      return 1
    fi
  done

  return 0
}

main() {
  gpgp::assert_gpgp_config
  gpgp::assert_roles_valid

  local cmd="${1:-}"

  if [[ -z "${cmd}" ]]; then
    gpgp::usage
    exit 1
  fi

  case "${cmd}" in
    -h|--help|help)
      gpgp::usage
      exit 1
      ;;

    recips)
      shift
      local roles="$@"
      gpgp::validate_roles ${roles}
      gpgp::cmd_recips ${roles}
      ;;

    ls)
      shift
      local roles="$@"
      gpgp::validate_roles ${roles}

      if [[ -z "${roles}" ]]; then
        roles="$(gpgp::ls_roles)"
      fi

      gpgp::cmd_ls true ${roles}
      ;;

    import)
      shift
      gpgp::cmd_import "$@"
      ;;

    add-key)
      shift
      gpgp::cmd_add-key "$@"
      ;;

    find-secrets)
      shift
      gpgp::cmd_find-secrets "$@"
      ;;

    reencrypt)
      shift
      gpgp::cmd_reencrypt "$@"
      ;;

    encrypt)
      shift
      gpgp::cmd_encrypt "$@"
      ;;

    # default is to encrypt a file or stdin
    *)
      gpgp::cmd_encrypt "$@"
      ;;

  esac
}

main "$@"
