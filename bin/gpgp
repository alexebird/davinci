#!/usr/bin/env bash
#
# gpg Plus
#
# by @alexebird
#

set -euo pipefail
[ -n "${GPGP_VERBOSE:-}" ] && set -x

GPG='gpg'

gpgp::role_path() {
  echo "${DAVINCI_GPGP_PATH}/gpg/roles/${1:-}"
}

gpgp::pub_key_path() {
  echo "${DAVINCI_GPGP_PATH}/gpg/public/${1:-}"
}

gpgp::secrets_path() {
  echo "${DAVINCI_GPGP_SECRETS_PATH}/${1:-}"
}

gpgp::ls_roles() {
  find "$(gpgp::role_path)" -type f -printf '%f\n' | sort
}

gpgp::is_role() {
  gpgp::ls_roles | grep -qP "^${1}$"
}

gpgp::match_pub_key() {
  local thing="${1}"
  find "$(gpgp::pub_key_path)" -type f -printf '%f\n' | grep -q "${thing}"
}

gpgp::is_comment() {
  local thing="${1}"
  [[ "${thing}" == '#'* ]]
}

#
# Recursively flatten roles into a list of the public key files.
#
gpgp::flatten_role() {
  local role="${1:?must pass role}" ; shift
  local level="${1:?must pass level}" ; shift
  local verbose="${1:-false}" ; shift

  local padding=""
  local one_padding="  "

  for (( i=0; i<level; i++ )); do
    padding+="${one_padding}"
  done

  if ! gpgp::is_role "${role}"; then
    >&2 echo "couldn't find role: ${role}"
    exit 1
  fi

  if [[ "${verbose}" == "true" ]]; then
    echo "${padding}role: ${role}"
  fi

  local role_path="$(gpgp::role_path "${role}")"
  local role_contents="$(cat "${role_path}")"

  for e in ${role_contents}; do
    if gpgp::is_comment "${e}"; then
      continue
    fi

    if gpgp::is_role "${e}"; then
      gpgp::flatten_role "${e}" "$((level + 1))" "${verbose}"
    elif gpgp::match_pub_key "${e}"; then
      if [[ "${verbose}" == "true" ]]; then
        echo "${padding}${one_padding}${e}"
      else
        gpgp::get_id_from_key_fname "${e}"
      fi
    else
      >&2 echo "${e} is not a role or public key"
    fi
  done

  if [[ "${verbose}" == "true" ]] && [[ "${level}" == "0" ]]; then
    echo
  fi
}

gpgp::get_id_from_key_fname() {
  local fname="$1"
  echo "${fname}" | sed -n -e's/.*id:\([0-9A-Z]\+\).*/\1/p'
}

_join() {
  local joint="${1:-}"
  shift
  local i=0
  for e in "$@"; do
    echo -n "${e}"
    ((i++))
    if [[ "${i}" != "$#" ]]; then
      echo -n "${joint}"
    else
      echo
    fi
  done
}

gpgp::recipients_list_from_role() {
  local role="${1}"
  local recips="$(gpgp::flatten_role "${role}" 0 false)"
  if [[ -n "${recips}" ]]; then
    echo "-r $(_join ' -r ' ${recips})"
  else
    return 1
  fi
}

gpgp::recipients_list_from_roles() {
  local list=''
  local recips

  for role in "$@"; do
    recips="$(gpgp::recipients_list_from_role "${role}")"

    if [[ "$?" != "0" ]]; then
      return 1
    fi

    if [[ -z "${list}" ]]; then
      list="${recips}"
    else
      list="${list} ${recips}"
    fi
  done

  echo "${list}"
}

gpgp::validate_roles() {
  local roles="$@"
  for role in "$@"; do
    if ! gpgp::is_role "${role}"; then
      >&2 echo "couldn't find role: ${role}"
      exit 1
    fi
  done
}

gpgp::cmd_recips() {
  local roles="$@"
  local recips
  recips="$(gpgp::recipients_list_from_roles ${roles})"
  if [[ "$?" != "0" ]]; then
    return 1
  else
    echo "${recips}"
  fi
}

gpgp::cmd_ls() {
  local verbose="$1" ; shift
  local roles="$@"

  for role in "$@"; do
    gpgp::flatten_role "${role}" 0 "${verbose}"
  done
}

gpgp::cmd_import() {
  local dry_run='false'

  while getopts "hn" opt; do
    case "${opt}" in
      n)
        dry_run='true'
        echo "dry run!"
        echo
        ;;
      h)
        cat <<HERE
  -n    dry run
  -h    show this help text
HERE
          exit
        ;;
      \?)
        echo "invalid option: -${OPTARG}" >&2
        exit 1
        ;;
      :)
        echo "option -${OPTARG} requires an argument." >&2
        exit 1
        ;;
    esac
  done

  # these are the key ids we want to end up having imported at the end of the process.
  local desired_keys="$(gpgp::cmd_ls false $(gpgp::ls_roles) | sort | uniq)"
  echo "$(gpgp::cmd_ls false $(gpgp::ls_roles) | sort | uniq)"

  # get currently imported public keys for the owner's domains
  local current_keys=$(
    "${GPG}" --list-keys \
      | grep -B1 -P "${DAVINCI_GPGP_EMAIL_DOMAINS}" \
      | grep -vP "${DAVINCI_GPGP_PUB_KEY_ID_BLACKLIST}" \
      | grep pub \
      | sed -n -e's;^pub.\+\/\(.\+\) .\+$;\1;p' \
      | sort \
      | uniq
  )

  # we will import everything in desired_keys.
  # we will --delete-key on everything that is in only current_keys.

  # take the set difference to get the keys only in current_keys.
  local delete_keys=$(
    comm -1 -3 \
      <(echo -e "${desired_keys}" | sed -e's/ /\n/g' | sort) \
      <(echo -e "${current_keys}" | sed -e's/ /\n/g' | sort)
  )

  echo desired: ${desired_keys}
  echo current: ${current_keys}
  echo delete:\ \ ${delete_keys}
  echo

  local desired_regex="$(_join '|' ${desired_keys})"
  local cmd

  if [[ -n "${desired_regex}" ]]; then
    for f in $(find "$(gpgp::pub_key_path)" -type f -name '*.pub' | grep -P "${desired_regex}") ; do
      cmd="${GPG} --import ${f}"
      echo "${cmd}"
      if [[ "${dry_run}" != "true" ]]; then
        ${cmd}
      fi
      echo
    done
  fi

  if [[ -s "${DAVINCI_GPGP_PATH}/gpg/ownertrust.txt" ]]; then
    "${GPG}" --import-ownertrust "${DAVINCI_GPGP_PATH}/gpg/ownertrust.txt"
  fi

  for f in ${delete_keys} ; do
    cmd=""${GPG}" --batch --yes --delete-key ${f}"
    echo "${cmd}"
    if [[ "${dry_run}" != "true" ]]; then
      ${cmd}
    fi
    echo
  done
}

gpgp::cmd_encrypt() {
  local gpg_opts=''
  local rm_orig='false'

  while getopts "ho:r" opt; do
    case "${opt}" in
      r)
        rm_orig="true"
        ;;
      o)
        gpg_opts="${OPTARG}"
        ;;
      h)
        cat <<HERE
gpgp encrypt [OPTIONS] ROLE [ROLE...] [FILE | -]

If FILE is equal to '-', then gpgp expects some data to piped in via stdin, and
writes the encrypted output in ascii-armor to stdout.

  -o    More options to be passed directly to gpg (wrap in quotes).
  -r    Remove the original unencrypted file.
  -h    Show this help text.
HERE
          exit
        ;;
      \?)
        echo "invalid option: -${OPTARG}" >&2
        exit 1
        ;;
      :)
        echo "option -${OPTARG} requires an argument." >&2
        exit 1
        ;;
    esac
  done

  shift $(($OPTIND - 1))

  # convert roles to an array
  local roles=( $@ )
  # convention: the last arg is the file to encrypt
  local file="${roles[${#roles[@]}-1]}"

  if [[ -n "${gpg_opts}" ]]; then
    gpg_opts="${gpg_opts} "
  fi

  # if no existing file is passed as the last arg, read from stdin, ascii armor, write to stdout.
  #if [[ -t 1 ]] || [[ "${file}" == '-' ]]; then
  if [[ "${file}" == '-' ]]; then
    # read from stdin, write to stdout
    gpgp::validate_roles ${roles}
    cat - | "${GPG}" ${gpg_opts}-a -e $(gpgp::cmd_recips ${roles}) -o-

  # if a file is passed as the last arg, encrypt it.
  elif [[ -f "${file}" ]]; then
    # remove the file from the list of args so we are only left with a list of roles
    unset 'roles[${#roles[@]}-1]'
    outf=''
    gpgp::validate_roles ${roles}
    "${GPG}" ${gpg_opts}-e $(gpgp::cmd_recips ${roles}) "${file}"

    if [[ "${rm_orig}" == "true" ]]; then
      echo "encrypted '${file}' -> '${file}.gpg'"
      rm -v "${file}"
    fi
  else
    echo "gpgp: error: file doesnt exist: ${file}"
    exit 1
  fi
}

gpgp::secrets_find_role_file() {
  local dir="${1:?must pass dir}" ; shift
  local orig_dir="${dir}"
  local role_file

  while true; do
    role_file="${dir}/gpgp-role"

    if [[ -f "${role_file}" ]]; then
      if [[ "$(cat "${role_file}" | wc -l )" != "1" ]] || ! [[ -s "${role_file}" ]]; then
        >&2 echo "role file ${role_file} must contain exactly one role."
        echo ""
        return 1
      fi

      echo "${role_file}"
      return 0

    # if we can't move upwards anymore
    elif [[ "${DAVINCI_GPGP_SECRETS_PATH%/}" == "${dir%/}" ]]; then
      echo ""
      return 1

    else
      dir="$(dirname "${dir}")"
    fi
  done
}

# The assumption is that the secrets dir is versioned, so this can do potentially
# destructive actions.
gpgp::secrets_reencrypt_dir() {
  local dir="${1:?must pass dir}" ; shift
  local dry_run="${1:-false}" ; shift

  local role_file="$(gpgp::secrets_find_role_file "${dir}")"
  # if there's no role file, check if dir only has dirs in it, meaning
  # there are no secrets in dir to protect from not being encrypted.
  if [[ -z "${role_file}" ]]; then
    # how many regular files in are in dir?
    if [[ "$(find "${dir}" -maxdepth 1 -name '.git' -prune -o -type f -print | wc -l)" == "0" ]]; then
      # if there are none, don't both to do anything else because the dir has no secrets to encrypt
      :
      return 0
    else
      >&2 echo "role file not found for directory ${dir} or in any parent dir."
      return 1
    fi
  fi

  local role="$(cat "${role_file}")"
  if [[ -z "${role}" ]]; then
    return 1
  fi

  gpgp::validate_roles ${role}
  echo "dir:  ${dir}"
  echo "role: ${role} (${role_file})"

  # if it ends with gpg, re-encrypt.
  for secret in $(find "${dir}" -maxdepth 1 -type f -name '*.gpg') ; do
    echo "+/- ${secret}"
    if [[ "${dry_run}" == "false" ]]; then
      local tmp_secret="${secret/%gpg/__new.gpg}"
      rm -f "${tmp_secret}"
      # leave no unencrypted secret on disk
      cat "${secret}" \
        | "${GPG}" -d -o- \
        | "${GPG}" -e $(gpgp recips ${role}) -o"${tmp_secret}" \
        && mv "${tmp_secret}" "${secret}"
    fi
  done

  # if it doesn't end with gpg, just encrypt and delete original.
  for secret in $(find "${dir}" -maxdepth 1 -name '.git' -prune -o \( -type f -a -not -name '*.gpg' -a -not -name 'gpgp-role' \) -print) ; do
    echo "+   ${secret}"
    if [[ "${dry_run}" == "false" ]]; then
      gpgp -o '--batch --yes' "${role}" "${secret}"
      rm -v "${secret}"
    fi
  done
}

gpgp::cmd_add-key() {
  local dry_run='false'

  while getopts "hn" opt; do
    case "${opt}" in
      n)
        dry_run='true'
        echo "dry run!"
        echo
        ;;
      h)
        cat <<HERE
gpgp add-key [OPTIONS]

Reads a public gpg key from stdin and stores it by the correct conventions.

  -n    dry run
  -h    show this help text
HERE
          exit
        ;;
      \?)
        echo "invalid option: -${OPTARG}" >&2
        exit 1
        ;;
      :)
        echo "option -${OPTARG} requires an argument." >&2
        exit 1
        ;;
    esac
  done

  shift $(($OPTIND - 1))

  local new_tmp="$(gpgp::pub_key_path '_tmp-new.pub')"
  cat - > "${new_tmp}"

  if ! grep -q 'BEGIN PGP PUBLIC KEY BLOCK' "${new_tmp}"; then
    echo "gpgp add-key: input doesnt seem to be a public key"
    return 1
  fi

  local key_fingerprint="$(gpg --with-fingerprint "${new_tmp}" 2>&1)"

  local key_id_short="$(echo "${key_fingerprint}" | ruby -ne '$_ =~ /^pub.+\/([0-9A-Z]+)/ && puts($1)')"
  local role_name="$(echo "${key_fingerprint}" | ruby -ne '$_ =~ /\<(.+)@/ && puts($1)')"
  local key_size="$(echo "${key_fingerprint}" | ruby -ne '$_ =~ /^pub\s+([0-9A-Z]+)\// && puts($1)')"
  local email="$(echo "${key_fingerprint}" | ruby -ne '$_ =~ /\<(.+)\>/ && puts($1)')"
  local key_id_long="$(echo "${key_fingerprint}" | ruby -ne '$_ =~ /Key fingerprint = ([0-9A-Z ]+)$/ && puts($1.gsub(/\s+/, ""))')"

  local key_fname="${email}-${key_size}-id:${key_id_short}.pub"

  if [[ "${dry_run}" == 'true' ]]; then
    rm -f "${new_tmp}"
    echo "key fname: ${key_fname}"
    echo "role name: ${role_name}"
  else
    mv -f "${new_tmp}" "$(gpgp::pub_key_path "${key_fname}")"
    echo "${key_fname}" > "$(gpgp::role_path "${role_name}")"
    if ! grep -q "${key_id_long}" "${DAVINCI_GPGP_PATH}/gpg/ownertrust.txt"; then
      echo "${key_id_long}:6:" >> "${DAVINCI_GPGP_PATH}/gpg/ownertrust.txt"
    fi
  fi
}

gpgp::cmd_reencrypt() {
  local dry_run='false'
  local secrets_path

  while getopts "hn" opt; do
    case "${opt}" in
      n)
        dry_run='true'
        echo "dry run!"
        echo
        ;;
      h)
        cat <<HERE
gpgp reencrypt [OPTIONS] [SECRETS_PATH]

SECRETS_PATH defaults to DAVINCI_GPGP_SECRETS_PATH, otherwise
must be inside DAVINCI_GPGP_SECRETS_PATH.

  -n    dry run
  -h    show this help text
HERE
          exit
        ;;
      \?)
        echo "invalid option: -${OPTARG}" >&2
        exit 1
        ;;
      :)
        echo "option -${OPTARG} requires an argument." >&2
        exit 1
        ;;
    esac
  done

  shift $(($OPTIND - 1))

  secrets_path="${1:-}"

  if [[ -z "${secrets_path}" ]]; then
    secrets_path="${DAVINCI_GPGP_SECRETS_PATH}"
  elif [[ "${secrets_path}" == *..* ]]; then
    echo "no '..' allowed in SECRETS_PATH"
    exit 1
  else
    secrets_path="${DAVINCI_GPGP_SECRETS_PATH}/${secrets_path}"
  fi

  # try to do a dry run first
  echo "checking for roles"
  echo "=================="
  if gpgp::cmd_reencrypt_dirs 'true' "${secrets_path}"; then
    echo "check passed. ready to encrypt."
    echo

    if [[ "${dry_run}" == 'false' ]]; then
      echo "re-encrypting secrets"
      echo "====================="
      gpgp::cmd_reencrypt_dirs 'false' "${secrets_path}"
    fi
  else
    echo "check failed. no encryption was done."
  fi
}

gpgp::cmd_find-secrets() {
  local search_terms="$@"
  local grep_pattern=''

  for t in ${search_terms}; do
    grep_pattern=" -e ${t}"
  done

  if [[ -n "${grep_pattern}" ]]; then
    grep_pattern=" | grep --color=always -iP ${grep_pattern}"
  fi

  eval find "${DAVINCI_GPGP_SECRETS_PATH}" -type f -name '*.gpg' ${grep_pattern}
}

gpgp::cmd_reencrypt_dirs() {
  local dry_run="$1" ; shift
  local secrets_path="$1" ; shift
  for dir in $(find "${secrets_path}" -name '.git' -prune -o -type d -print) ; do
    gpgp::secrets_reencrypt_dir "${dir}" "${dry_run}" || return 1
    echo
  done
}

#gpgp::roles_completer() {
  #gpgp::ls_roles
  #echo
#}

#complete -F _gpgp_roles_completer _gpgp_recipients_list

gpgp::usage() {
  cat <<HERE
gpgp ROLES...

Reads from STDIN, writes to STDOUT in ascii armor.


gpgp ROLES... FILE

Encrypts FILE without ascii armor in the same dir.


gpgp SUBCMD

Subcommands:

(run with -h for more)

encrypt     Ecrypt a file with one or more roles.
recips      Prints a \`-r FOOBAR -r BAR...\` string for use with gpg.
ls          Prints the role heirarchy for all roles.
ls ROLE...  Prints the role heirarchy for the specified roles.
import      Imports the public keys at DAVINCI_GPGP_PATH, and the ownertrust.txt file.
add-key     Read a public gpg key from stdin, store it by the correct conventions, add it to ownertrust.txt.
reencrypt   Reencrypts the secrets at DAVINCI_GPGP_SECRETS_PATH.
HERE
}

gpgp::assert_gpgp_config() {
  if [[ -z "${DAVINCI_GPGP_EMAIL_DOMAINS:-}" ]]; then
    echo "gpgp cannot be used when DAVINCI_GPGP_EMAIL_DOMAINS is not set."
    return 1
  fi
  return 0
}

main() {
  gpgp::assert_gpgp_config

  local cmd="${1:-}"

  if [[ -z "${cmd}" ]]; then
    gpgp::usage
    exit 1
  fi

  case "${cmd}" in
    recips)
      shift
      local roles="$@"
      gpgp::validate_roles ${roles}
      gpgp::cmd_recips ${roles}
      ;;

    ls)
      shift
      local roles="$@"
      gpgp::validate_roles ${roles}

      if [[ -z "${roles}" ]]; then
        roles="$(gpgp::ls_roles)"
      fi

      gpgp::cmd_ls true ${roles}
      ;;

    import)
      shift
      gpgp::cmd_import "$@"
      ;;

    add-key)
      shift
      gpgp::cmd_add-key "$@"
      ;;

    find-secrets)
      shift
      gpgp::cmd_find-secrets "$@"
      ;;

    reencrypt)
      shift
      gpgp::cmd_reencrypt "$@"
      ;;

    encrypt)
      shift
      gpgp::cmd_encrypt "$@"
      ;;

    # default is to encrypt a file or stdin
    *)
      gpgp::cmd_encrypt "$@"
      ;;

  esac
}

main "$@"
